<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GameBird</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            cursor: none;
        }
        canvas {
            display: block;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
        }
        #crosshair {
            position: absolute;
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 100;
            transition: all 0.1s;
        }
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
        }
        #crosshair::before {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }
        #crosshair::after {
            height: 2px;
            width: 100%;
            top: 50%;
            transform: translateY(-50%);
        }
        #crosshair.shiftlock {
            border: 2px solid yellow;
            border-radius: 50%;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0,0,0,0.6);
            padding: 15px 25px;
            border-radius: 10px;
            text-align: center;
            font-size: 16px;
        }
        #shiftlock-indicator {
            color: yellow;
            font-weight: bold;
        }
        #fullscreen-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: rgba(0,0,0,0.6);
            color: white;
            border: 2px solid white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            z-index: 100;
            transition: all 0.3s;
        }
        #fullscreen-btn:hover {
            background: rgba(255,255,255,0.2);
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <button id="fullscreen-btn">üñ•Ô∏è Plein √©cran (F11)</button>
    <div id="ui">
        <div>ü¶Ö Altitude: <span id="altitude">0</span>m</div>
        <div>‚ö° √ânergie: <span id="energy">100</span>%</div>
        <div>‚úàÔ∏è Mode: <span id="mode">Au sol</span></div>
        <div id="egg-status" style="display: none;">ü•ö ≈íuf transport√©</div>
        <div id="nest-hint" style="display: none; color: yellow;">üìç Appuyez sur R pour prendre/d√©poser</div>
        <div id="shiftlock-indicator" style="display: none;">üîí SHIFT LOCK ACTIV√â</div>
    </div>
    <div id="crosshair"></div>
    <div id="instructions">
        üéÆ Souris pour regarder | ZQSD pour bouger | F pour voler/atterrir | E (maintenir) pour tirer | SHIFT pour mode vis√©e libre | R pour prendre/d√©poser un ≈ìuf
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let bird, birdBody, birdHead, beak;
        let trees = [];
        let nests = [];
        let laserBeam = null;
        let carriedEggMesh = null;
        let nearestNest = null;
        let keys = {};
        let cameraRotation = { horizontal: 0, vertical: 0 };
        let isFlying = false;
        let energy = 100;
        let velocity = { x: 0, y: 0, z: 0 };
        let shiftLockMode = false;
        let crosshairPos = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
        let isPointerLocked = false;
        let isRightMouseDown = false;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 50, 200);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            createBird();
            createForest();
            createGround();

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('contextmenu', (e) => e.preventDefault());
            document.addEventListener('pointerlockchange', onPointerLockChange);
            
            const fullscreenBtn = document.getElementById('fullscreen-btn');
            fullscreenBtn.addEventListener('click', toggleFullscreen);
            
            updateCrosshairPosition();
            renderer.domElement.requestPointerLock();
            animate();
        }

        function createBird() {
            bird = new THREE.Group();

            const bodyGeometry = new THREE.SphereGeometry(0.8, 32, 32);
            bodyGeometry.scale(1, 0.9, 1.4);
            const bodyMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x7D8C9E,
                shininess: 30,
                specular: 0x444444
            });
            birdBody = new THREE.Mesh(bodyGeometry, bodyMaterial);
            birdBody.castShadow = true;
            bird.add(birdBody);

            const chestGeometry = new THREE.SphereGeometry(0.65, 32, 32);
            chestGeometry.scale(0.9, 0.8, 1.1);
            const chestMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xC5C9CE,
                shininess: 40,
                specular: 0x9B59B6,
                emissive: 0x4A148C,
                emissiveIntensity: 0.15
            });
            const chest = new THREE.Mesh(chestGeometry, chestMaterial);
            chest.position.set(0, -0.2, 0.3);
            bird.add(chest);

            const headGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            headGeometry.scale(0.9, 1, 0.9);
            const headMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x6B7A8F,
                shininess: 30,
                specular: 0x333333
            });
            birdHead = new THREE.Mesh(headGeometry, headMaterial);
            birdHead.position.set(0, 0.3, 0.8);
            birdHead.castShadow = true;
            bird.add(birdHead);

            const beakGeometry = new THREE.ConeGeometry(0.12, 0.35, 8);
            const beakMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xE8C4A8,
                shininess: 20
            });
            beak = new THREE.Mesh(beakGeometry, beakMaterial);
            beak.rotation.x = -Math.PI / 2;
            beak.position.set(0, 0.2, 1.2);
            bird.add(beak);

            const eyeGeometry = new THREE.SphereGeometry(0.08, 16, 16);
            const eyeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x000000,
                shininess: 100,
                specular: 0xFFFFFF
            });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.25, 0.35, 1.0);
            bird.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.25, 0.35, 1.0);
            bird.add(rightEye);

            const pupilGeometry = new THREE.SphereGeometry(0.03, 8, 8);
            const pupilMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
            const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            leftPupil.position.set(-0.22, 0.38, 1.05);
            bird.add(leftPupil);
            const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            rightPupil.position.set(0.28, 0.38, 1.05);
            bird.add(rightPupil);

            const wingGeometry = new THREE.BoxGeometry(2.2, 0.15, 1);
            const wingMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x5A6B7D,
                shininess: 25,
                specular: 0x222222
            });
            
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.position.set(-1.1, 0, -0.1);
            leftWing.rotation.z = 0.1;
            leftWing.castShadow = true;
            bird.add(leftWing);

            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            rightWing.position.set(1.1, 0, -0.1);
            rightWing.rotation.z = -0.1;
            rightWing.castShadow = true;
            bird.add(rightWing);

            const featherGeometry = new THREE.BoxGeometry(2, 0.16, 0.3);
            const featherMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x2C3E50,
                shininess: 30
            });
            
            const leftFeather = new THREE.Mesh(featherGeometry, featherMaterial);
            leftFeather.position.set(-1, 0, -0.5);
            leftFeather.rotation.z = 0.1;
            bird.add(leftFeather);

            const rightFeather = new THREE.Mesh(featherGeometry, featherMaterial);
            rightFeather.position.set(1, 0, -0.5);
            rightFeather.rotation.z = -0.1;
            bird.add(rightFeather);

            const tailGeometry = new THREE.ConeGeometry(0.4, 0.9, 8);
            tailGeometry.rotateX(-Math.PI / 2);
            const tailMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x4A5A6A,
                shininess: 25
            });
            const tail = new THREE.Mesh(tailGeometry, tailMaterial);
            tail.position.set(0, 0.1, -1.1);
            tail.castShadow = true;
            bird.add(tail);

            const tailBandGeometry = new THREE.CylinderGeometry(0.41, 0.2, 0.15, 8);
            tailBandGeometry.rotateX(-Math.PI / 2);
            const tailBandMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x1A1A1A
            });
            const tailBand = new THREE.Mesh(tailBandGeometry, tailBandMaterial);
            tailBand.position.set(0, 0.1, -1.5);
            bird.add(tailBand);

            const legGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.4, 8);
            const legMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xD4A574,
                shininess: 10
            });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.2, -0.9, 0);
            bird.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.2, -0.9, 0);
            bird.add(rightLeg);

            bird.position.set(0, 5, 0);
            scene.add(bird);
        }

        function createForest() {
            // Texture d'√©corce r√©aliste
            const barkCanvas = document.createElement('canvas');
            barkCanvas.width = 256;
            barkCanvas.height = 512;
            const barkCtx = barkCanvas.getContext('2d');
            
            // Base marron fonc√©
            const barkGradient = barkCtx.createLinearGradient(0, 0, 256, 0);
            barkGradient.addColorStop(0, '#3D2817');
            barkGradient.addColorStop(0.5, '#5C4033');
            barkGradient.addColorStop(1, '#3D2817');
            barkCtx.fillStyle = barkGradient;
            barkCtx.fillRect(0, 0, 256, 512);
            
            // Lignes verticales d'√©corce
            for (let i = 0; i < 150; i++) {
                const x = Math.random() * 256;
                const shade = Math.floor(Math.random() * 40) + 40;
                barkCtx.strokeStyle = `rgba(${shade}, ${shade - 10}, ${shade - 20}, 0.6)`;
                barkCtx.lineWidth = 1 + Math.random() * 2;
                barkCtx.beginPath();
                barkCtx.moveTo(x, 0);
                barkCtx.lineTo(x + (Math.random() - 0.5) * 20, 512);
                barkCtx.stroke();
            }
            
            // N≈ìuds dans le bois
            for (let i = 0; i < 8; i++) {
                const x = Math.random() * 256;
                const y = Math.random() * 512;
                const size = 10 + Math.random() * 20;
                const knotGradient = barkCtx.createRadialGradient(x, y, 0, x, y, size);
                knotGradient.addColorStop(0, '#2C1810');
                knotGradient.addColorStop(1, '#5C4033');
                barkCtx.fillStyle = knotGradient;
                barkCtx.beginPath();
                barkCtx.ellipse(x, y, size, size * 0.7, Math.random() * Math.PI, 0, Math.PI * 2);
                barkCtx.fill();
            }
            
            const barkTexture = new THREE.CanvasTexture(barkCanvas);
            barkTexture.wrapS = THREE.RepeatWrapping;
            barkTexture.wrapT = THREE.RepeatWrapping;
            barkTexture.repeat.set(1, 3);

            for (let i = 0; i < 100; i++) {
                const x = (Math.random() - 0.5) * 200;
                const z = (Math.random() - 0.5) * 200;
                
                if (Math.abs(x) < 10 && Math.abs(z) < 10) continue;

                const treeHeight = 5 + Math.random() * 10;
                const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, treeHeight, 12);
                const trunkMaterial = new THREE.MeshPhongMaterial({ 
                    map: barkTexture,
                    color: 0xFFFFFF,
                    shininess: 5,
                    bumpScale: 0.3
                });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.set(x, treeHeight / 2, z);
                trunk.castShadow = true;
                trunk.receiveShadow = true;
                scene.add(trunk);

                const foliageGeometry = new THREE.SphereGeometry(3, 16, 16);
                
                // Texture de feuilles r√©aliste
                const leafCanvas = document.createElement('canvas');
                leafCanvas.width = 256;
                leafCanvas.height = 256;
                const leafCtx = leafCanvas.getContext('2d');
                
                // Base verte
                const leafGradient = leafCtx.createRadialGradient(128, 128, 0, 128, 128, 128);
                leafGradient.addColorStop(0, '#4A7C2F');
                leafGradient.addColorStop(0.5, '#3D6626');
                leafGradient.addColorStop(1, '#2F501D');
                leafCtx.fillStyle = leafGradient;
                leafCtx.fillRect(0, 0, 256, 256);
                
                // Feuilles individuelles
                for (let j = 0; j < 100; j++) {
                    const x = Math.random() * 256;
                    const y = Math.random() * 256;
                    const size = 8 + Math.random() * 12;
                    const angle = Math.random() * Math.PI * 2;
                    
                    leafCtx.save();
                    leafCtx.translate(x, y);
                    leafCtx.rotate(angle);
                    
                    // Forme de feuille
                    const green = 90 + Math.random() * 40;
                    leafCtx.fillStyle = `rgba(${green - 40}, ${green}, ${green - 50}, 0.7)`;
                    leafCtx.beginPath();
                    leafCtx.ellipse(0, 0, size, size * 0.5, 0, 0, Math.PI * 2);
                    leafCtx.fill();
                    
                    // Nervure centrale
                    leafCtx.strokeStyle = `rgba(${green - 60}, ${green - 20}, ${green - 60}, 0.5)`;
                    leafCtx.lineWidth = 1;
                    leafCtx.beginPath();
                    leafCtx.moveTo(-size, 0);
                    leafCtx.lineTo(size, 0);
                    leafCtx.stroke();
                    
                    leafCtx.restore();
                }
                
                const leafTexture = new THREE.CanvasTexture(leafCanvas);
                
                const foliageMaterial = new THREE.MeshPhongMaterial({ 
                    map: leafTexture,
                    color: 0xFFFFFF,
                    shininess: 15,
                    transparent: true,
                    opacity: 0.9,
                    side: THREE.DoubleSide
                });
                const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                foliage.position.set(x, treeHeight + 2, z);
                foliage.castShadow = true;
                foliage.receiveShadow = true;
                scene.add(foliage);

                if (Math.random() > 0.7) {
                    createNest(x, treeHeight + 4.5, z);
                }

                trees.push({ trunk, foliage });
            }
        }

        function createNest(x, y, z) {
            const nestGroup = new THREE.Group();
            
            // Texture de brindilles pour le nid
            const twigCanvas = document.createElement('canvas');
            twigCanvas.width = 128;
            twigCanvas.height = 128;
            const twigCtx = twigCanvas.getContext('2d');
            twigCtx.fillStyle = '#6B5844';
            twigCtx.fillRect(0, 0, 128, 128);
            
            // Brindilles entrecrois√©es
            for (let i = 0; i < 50; i++) {
                twigCtx.strokeStyle = `rgba(${90 + Math.random() * 40}, ${70 + Math.random() * 30}, ${50 + Math.random() * 20}, 0.8)`;
                twigCtx.lineWidth = 2;
                twigCtx.beginPath();
                twigCtx.moveTo(Math.random() * 128, Math.random() * 128);
                twigCtx.lineTo(Math.random() * 128, Math.random() * 128);
                twigCtx.stroke();
            }
            
            const twigTexture = new THREE.CanvasTexture(twigCanvas);
            
            // Nid BEAUCOUP plus gros
            const nestGeometry = new THREE.TorusGeometry(0.8, 0.25, 16, 20);
            const nestMaterial = new THREE.MeshPhongMaterial({ 
                map: twigTexture,
                color: 0x8B7355,
                shininess: 5
            });
            const nest = new THREE.Mesh(nestGeometry, nestMaterial);
            nest.rotation.x = Math.PI / 2;
            nest.castShadow = true;
            nestGroup.add(nest);

            // Base du nid plus grosse
            const baseGeometry = new THREE.CylinderGeometry(0.7, 0.5, 0.2, 16);
            const baseMaterial = new THREE.MeshPhongMaterial({ 
                map: twigTexture,
                color: 0x7A6348,
                shininess: 5
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = -0.15;
            base.castShadow = true;
            nestGroup.add(base);

            const numEggs = 2 + Math.floor(Math.random() * 2);
            const eggs = [];
            
            // Texture d'≈ìuf avec petits points
            const eggCanvas = document.createElement('canvas');
            eggCanvas.width = 64;
            eggCanvas.height = 64;
            const eggCtx = eggCanvas.getContext('2d');
            eggCtx.fillStyle = '#F5E6D3';
            eggCtx.fillRect(0, 0, 64, 64);
            
            // Petites taches brunes
            for (let i = 0; i < 30; i++) {
                eggCtx.fillStyle = `rgba(${140 + Math.random() * 40}, ${100 + Math.random() * 30}, ${70 + Math.random() * 20}, 0.4)`;
                eggCtx.beginPath();
                eggCtx.arc(Math.random() * 64, Math.random() * 64, 1 + Math.random() * 2, 0, Math.PI * 2);
                eggCtx.fill();
            }
            
            const eggTexture = new THREE.CanvasTexture(eggCanvas);
            
            for (let i = 0; i < numEggs; i++) {
                const eggGeometry = new THREE.SphereGeometry(0.25, 16, 16);
                eggGeometry.scale(1, 1.4, 1);
                const eggMaterial = new THREE.MeshPhongMaterial({ 
                    map: eggTexture,
                    color: 0xFFFFFF,
                    shininess: 30,
                    specular: 0x444444
                });
                const egg = new THREE.Mesh(eggGeometry, eggMaterial);
                const angle = (i / numEggs) * Math.PI * 2;
                egg.position.set(Math.cos(angle) * 0.3, 0.05, Math.sin(angle) * 0.3);
                egg.rotation.z = Math.random() * 0.3 - 0.15;
                egg.userData.isEgg = true;
                egg.userData.nestRef = null;
                egg.castShadow = true;
                nestGroup.add(egg);
                eggs.push(egg);
            }

            nestGroup.position.set(x, y, z);
            nestGroup.castShadow = true;
            scene.add(nestGroup);
            
            const nestData = { group: nestGroup, eggs: eggs, position: new THREE.Vector3(x, y, z) };
            
            // R√©f√©rencer le nid dans chaque ≈ìuf
            for (const egg of eggs) {
                egg.userData.nestRef = nestData;
            }
            
            nests.push(nestData);
        }

        function createGround() {
            // Texture d'herbe r√©aliste
            const grassCanvas = document.createElement('canvas');
            grassCanvas.width = 512;
            grassCanvas.height = 512;
            const grassCtx = grassCanvas.getContext('2d');
            
            // Base vert fonc√©
            const grassGradient = grassCtx.createRadialGradient(256, 256, 0, 256, 256, 256);
            grassGradient.addColorStop(0, '#3A5F2A');
            grassGradient.addColorStop(0.5, '#2D4A1F');
            grassGradient.addColorStop(1, '#243D18');
            grassCtx.fillStyle = grassGradient;
            grassCtx.fillRect(0, 0, 512, 512);
            
            // Brins d'herbe
            for (let i = 0; i < 2000; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const greenShade = Math.floor(Math.random() * 60) + 80;
                grassCtx.strokeStyle = `rgba(${greenShade - 40}, ${greenShade}, ${greenShade - 60}, 0.4)`;
                grassCtx.lineWidth = 1;
                grassCtx.beginPath();
                grassCtx.moveTo(x, y);
                grassCtx.lineTo(x + (Math.random() - 0.5) * 4, y + Math.random() * 8);
                grassCtx.stroke();
            }
            
            // Touches de terre
            for (let i = 0; i < 100; i++) {
                grassCtx.fillStyle = `rgba(${80 + Math.random() * 30}, ${60 + Math.random() * 20}, ${40 + Math.random() * 15}, 0.3)`;
                grassCtx.beginPath();
                grassCtx.arc(Math.random() * 512, Math.random() * 512, 3 + Math.random() * 8, 0, Math.PI * 2);
                grassCtx.fill();
            }
            
            const grassTexture = new THREE.CanvasTexture(grassCanvas);
            grassTexture.wrapS = THREE.RepeatWrapping;
            grassTexture.wrapT = THREE.RepeatWrapping;
            grassTexture.repeat.set(20, 20);
            
            const groundGeometry = new THREE.PlaneGeometry(300, 300);
            const groundMaterial = new THREE.MeshPhongMaterial({ 
                map: grassTexture,
                color: 0xFFFFFF,
                shininess: 5
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
        }

        function getBeakWorldPosition() {
            const beakTip = new THREE.Vector3(0, 0.2, 1.4);
            const worldPos = new THREE.Vector3();
            bird.localToWorld(worldPos.copy(beakTip));
            return worldPos;
        }

        function getLaserDirection() {
            if (shiftLockMode) {
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                const deltaX = (crosshairPos.x - centerX) / window.innerWidth * 2;
                const deltaY = -(crosshairPos.y - centerY) / window.innerHeight * 2;

                const direction = new THREE.Vector3(deltaX, deltaY, -1);
                direction.applyQuaternion(camera.quaternion);
                direction.normalize();
                return direction;
            } else {
                const forward = new THREE.Vector3(0, 0, 1);
                forward.applyQuaternion(bird.quaternion);
                return forward;
            }
        }

        function updateLaser() {
            if (keys['e'] && energy > 0) {
                if (!laserBeam) {
                    const laserGeometry = new THREE.CylinderGeometry(0.15, 0.15, 200, 8);
                    const laserMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xFF0000,
                        emissive: 0xFF0000,
                        emissiveIntensity: 2,
                        transparent: true,
                        opacity: 0.8
                    });
                    laserBeam = new THREE.Mesh(laserGeometry, laserMaterial);
                    scene.add(laserBeam);
                }

                const beakPos = getBeakWorldPosition();
                const direction = getLaserDirection();

                const laserStart = beakPos.clone();
                const laserEnd = beakPos.clone().add(direction.clone().multiplyScalar(200));

                laserBeam.position.copy(laserStart).lerp(laserEnd, 0.5);

                laserBeam.quaternion.setFromUnitVectors(
                    new THREE.Vector3(0, 1, 0),
                    direction.clone().normalize()
                );

                energy = Math.max(0, energy - 0.5);
            } else {
                if (laserBeam) {
                    scene.remove(laserBeam);
                    laserBeam = null;
                }
                energy = Math.min(100, energy + 0.3);
            }
        }

        function handleEggInteraction() {
            if (carriedEgg) {
                if (nearestNest) {
                    carriedEgg.position.copy(nearestNest.position);
                    carriedEgg.position.y += 0.1;
                    scene.add(carriedEgg);
                    nearestNest.eggs.push(carriedEgg);
                    carriedEgg = null;
                    document.getElementById('egg-status').style.display = 'none';
                }
            } else {
                if (nearestNest && nearestNest.eggs.length > 0) {
                    carriedEgg = nearestNest.eggs.pop();
                    scene.remove(carriedEgg);
                    document.getElementById('egg-status').style.display = 'block';
                }
            }
        }

        function checkNearbyNests() {
            let closest = null;
            let minDist = 5;

            for (const nest of nests) {
                const dist = bird.position.distanceTo(nest.position);
                if (dist < minDist) {
                    minDist = dist;
                    closest = nest;
                }
            }

            nearestNest = closest;
            
            if (nearestNest && nearestNest.eggs.length > 0 && !carriedEggMesh) {
                document.getElementById('nest-hint').style.display = 'block';
            } else if (carriedEggMesh) {
                document.getElementById('nest-hint').innerHTML = 'üìç Appuyez sur R pour d√©poser';
                document.getElementById('nest-hint').style.display = 'block';
            } else {
                document.getElementById('nest-hint').style.display = 'none';
            }
        }

        function onKeyDown(e) {
            const key = e.key.toLowerCase();
            
            if (key === 'f' && !keys['f']) {
                isFlying = !isFlying;
                document.getElementById('mode').textContent = isFlying ? 'En vol' : 'Au sol';
            }

            if (key === 'r') {
                handleEggInteraction();
            }

            if (key === 'shift') {
                shiftLockMode = !shiftLockMode;
                const indicator = document.getElementById('shiftlock-indicator');
                const crosshair = document.getElementById('crosshair');
                
                if (shiftLockMode) {
                    indicator.style.display = 'block';
                    crosshair.classList.add('shiftlock');
                    document.exitPointerLock();
                    isPointerLocked = false;
                } else {
                    indicator.style.display = 'none';
                    crosshair.classList.remove('shiftlock');
                    crosshairPos = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
                    updateCrosshairPosition();
                    renderer.domElement.requestPointerLock();
                }
            }
            
            keys[key] = true;
        }

        function onKeyUp(e) {
            keys[e.key.toLowerCase()] = false;
        }

        function onMouseMove(e) {
            if (shiftLockMode) {
                if (isRightMouseDown) {
                    cameraRotation.horizontal -= e.movementX * 0.002;
                    cameraRotation.vertical += e.movementY * 0.002;
                    cameraRotation.vertical = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, cameraRotation.vertical));
                } else {
                    crosshairPos.x = e.clientX;
                    crosshairPos.y = e.clientY;
                    updateCrosshairPosition();
                }
            } else {
                cameraRotation.horizontal -= e.movementX * 0.002;
                cameraRotation.vertical += e.movementY * 0.002;
                cameraRotation.vertical = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, cameraRotation.vertical));
            }
        }

        function onMouseDown(e) {
            if (e.button === 2) {
                isRightMouseDown = true;
            }
        }

        function onMouseUp(e) {
            if (e.button === 2) {
                isRightMouseDown = false;
            }
        }

        function updateCrosshairPosition() {
            const crosshair = document.getElementById('crosshair');
            if (shiftLockMode) {
                crosshair.style.left = crosshairPos.x + 'px';
                crosshair.style.top = crosshairPos.y + 'px';
                crosshair.style.transform = 'translate(-50%, -50%)';
            } else {
                crosshair.style.left = '50%';
                crosshair.style.top = '50%';
                crosshair.style.transform = 'translate(-50%, -50%)';
            }
        }

        function requestPointerLock() {
            if (!shiftLockMode && !isPointerLocked) {
                renderer.domElement.requestPointerLock();
            }
        }

        function onPointerLockChange() {
            isPointerLocked = document.pointerLockElement === renderer.domElement;
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().then(() => {
                    renderer.domElement.requestPointerLock();
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

        function updateBird() {
            const moveSpeed = 0.3;

            if (keys['z']) {
                velocity.x += moveSpeed * Math.sin(cameraRotation.horizontal);
                velocity.z += moveSpeed * Math.cos(cameraRotation.horizontal);
                
                if (isFlying) {
                    velocity.y -= moveSpeed * Math.sin(cameraRotation.vertical);
                }
            }
            if (keys['s']) {
                velocity.x -= moveSpeed * Math.sin(cameraRotation.horizontal);
                velocity.z -= moveSpeed * Math.cos(cameraRotation.horizontal);
                
                if (isFlying) {
                    velocity.y += moveSpeed * Math.sin(cameraRotation.vertical);
                }
            }
            if (keys['q']) {
                velocity.x += moveSpeed * Math.cos(cameraRotation.horizontal);
                velocity.z -= moveSpeed * Math.sin(cameraRotation.horizontal);
            }
            if (keys['d']) {
                velocity.x -= moveSpeed * Math.cos(cameraRotation.horizontal);
                velocity.z += moveSpeed * Math.sin(cameraRotation.horizontal);
            }

            if (!isFlying) {
                velocity.y -= 0.08;
            }

            velocity.x *= 0.88;
            velocity.z *= 0.88;
            velocity.y *= 0.88;

            if (isFlying) {
                energy = Math.max(0, energy - 0.1);
                
                if (energy <= 0) {
                    isFlying = false;
                    document.getElementById('mode').textContent = 'Au sol';
                }
            }

            bird.position.add(new THREE.Vector3(velocity.x, velocity.y, velocity.z));

            if (bird.position.y < 1.5) {
                bird.position.y = 1.5;
                velocity.y = 0;
            }

            if (bird.position.y > 50) {
                bird.position.y = 50;
                velocity.y = 0;
            }

            bird.rotation.y = cameraRotation.horizontal;
            bird.rotation.x = cameraRotation.vertical * 0.3;

            // Mettre √† jour la position de l'≈ìuf port√©
            if (carriedEggMesh) {
                const eggPos = new THREE.Vector3(0, -0.8, 0.2);
                bird.localToWorld(eggPos);
                carriedEggMesh.position.copy(eggPos);
                carriedEggMesh.rotation.set(
                    bird.rotation.x * 0.5,
                    bird.rotation.y,
                    0
                );
            }

            const camDistance = 12;
            const camHeight = 4;
            camera.position.x = bird.position.x - Math.sin(cameraRotation.horizontal) * camDistance;
            camera.position.z = bird.position.z - Math.cos(cameraRotation.horizontal) * camDistance;
            camera.position.y = bird.position.y + camHeight + Math.sin(cameraRotation.vertical) * 3;
            
            const lookTarget = new THREE.Vector3(
                bird.position.x,
                bird.position.y + 1,
                bird.position.z
            );
            camera.lookAt(lookTarget);

            document.getElementById('altitude').textContent = Math.floor(bird.position.y);
            document.getElementById('energy').textContent = Math.floor(energy);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            updateBird();
            updateLaser();
            checkNearbyNests();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>